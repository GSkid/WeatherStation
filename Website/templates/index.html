<!DOCTYPE html>
<html lang="en" dir=ltr>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Weather Data API</title>
	<link rel="stylesheet" type="text/css" href="/static/css/index_stylesheet.css">
	<!-- Fonts -->
	<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600&display=swap" rel="stylesheet">
</head>

<body>
	<header>
		<h1 id="site-title">Weather Data API</h1>
		<div class="menu">
			<ul class="menu">
				<li class="nav"><a href="/" class="link">Home</a></li>
				<li class="nav"><a href="/about_me" class="link">About Me</a></li>
			</ul>
		</div>
	</header>

	<!-- API_GET BUTTON -->
	<a href="/api_get" target="_blank" id="button">
		<div class="svg-wrapper">
	    	<svg height="80" width="300" xmlns="http://www.w3.org/2000/svg">
	        	<rect id="shape" height="80" width="300" />
	        	<div id="text">
	          	<span class="spot"></span>Get Weather Data
	        	</div>
	      	</svg>
	    </div>
	</a>

	<div id="about">
		<h2 id="about-header">Get the Latest Weather Data Every 15 Minutes</h2>
		<p id="basic-info">
			Get up-to-date weather data as a json with updates every 15 minutes. Comprised of data including temperature, humidity, light level, wind speed, wind direction, and precipitation amount, you can design your system knowing that your data will be accurate to the most recent 15 minute mark. The Weather Data API also includes forecast data generated by a neural network that uses past data to inform future precipitation trends.
		</p>
		<hr style="height:2px;border-width:0;width:60%;color:white;background-color:white">
		<p id="update-status">
			NOTE: This project is not complete (WIP). As of now, the weather data is not real because hardware and subsequent firmware is still being built, but should be up within the month. This page will be updated as soon as relevant weather data can be pulled from the api. For now, the only thing that updates is the timestamp.
		</p>
	</div>
	
	<div id="learn-more">
		<hr style="height:2px;border-width:0;width:60%;color:white;background-color:white">
		<h2 id="learn-more-header">More About How This Project Works</h2>
		<p id="learn-more-text">
			This project is mostly broken down into two parts: the weather station and the website. The weather station is responsible for getting the weather data from the sensors, transmitting the data wirelessly to the master node, and updating all relevant csv files to keep track of the information. The website is pretty self-explanatory, just host the website so that the data is available to the public. Both parts required a lot of effort and are relevant to different parts of embedded systems engineering. <br><br>The weather station uses the raspberry pi, which runs embedded linux, to generate weather data from sensors attached to an external sensor node. Both the sensor node and the raspberry pi (operating as master) are equipped with radio transceivers (nRF24L01 modules) in order to communicate wirelessly. The data is transmitted in the form of a data struct in order to minimize size, therefore reducing both message transmission duration and potential errors. With fewer messages sent (due to fragmentation), the fewer chances there are for errors. Once the master receives the full sensor data struct, the data is extracted to the D_Class object so that it can be used by the object's methods. Using these methods, the data gets written to the data stream csv file for the python neural network to use and to the csv output file for the Website to convert and post.<br><br>The website is expected to run in a separate instance from the weather station executable so that one instance can operate the weather station and the other can host the website. The website is primarily hosted by Flask, which is a python module that allows for URI requests to be handled individually, so that different requests can result in different operations. For example, at the URI "about_me", we simply just render a different html document other than the home page. Then at the "api_get" URI, we don't render any html documents and instead convert the weather data csv file into a json and post that in a different tab. This allows us to easily and reliably control the website framework with just a python file. However, the drawback of Flask is that it is not suited for running as a primary web server gateway interface (WSGI) because of its limited load handling. This means that we need another framework to actually handle incoming and outgoing http requests while still running flask to host the website. So I chose to use NGINX which is an open source web hosting framework with built-in load handling (which is handy if I ever decide to scale up the web hosting). NGINX is responsible for listening on port 80 for incoming HTTP requests and routing the request to the appropriate server. In this case, we only have a single server (which is the Flask application being hosted on the Raspberry Pi's local IP address) so we just need to tell Flask to reverse proxy the request to the Raspberry Pi's local IP. The problem here is that a lot of the request headers get messed up between NGINX and Flask, so we need an intermediary to manage the process of transferring the requests between NGINX and Flask. For this application, I chose to use Gunicorn which is a WSGI capable of handling NGINX requests and reformatting the headers so Flask can appropriately host the website. Gunicorn is also capable of sending the proper http request in the reverse direction from Flask to NGINX so we can send our webpages back out to the client. The last part of the website hosting process is to assign an external static IP so clients can actually visit the website without manually changing the DNS changing every time the external IP changes. One way to do this is by purchasing a static IP from an ISP, but obviously this costs money. The other option is to use the service called NoIP which runs a program on your device which reports your external IP to the service so that it can re-map your external IP to the domain of your webiste. This means that anytime someone visits weatherdataapi.ddns.net, their request goes to my external IP which is my router. Then on the router, I configured a port forwarding rule which tells the router to forward any incoming HTTP requests (port 80) to the IP address of the raspberry pi which is where the website is being hosted by Flask. The request then is received by NGINX who process and sends the request to Flask via Gunicorn where we are able to process the request and return the necessary information.<br><br>This whole operation is really fascinating to me and I will definitely continue working on the project until I'm able to get some relevant weather data from the sensors and I will update the website as soon as I do.
		</p>
	</div>





</body>
</html>